<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="NotMongo: A Maybe DuckDB Extension for JSON APIs">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@croloris">
    <meta name="twitter:author" content="@croloris">
    <meta name="twitter:description" content="NotMongo: A Maybe DuckDB Extension for JSON APIs">
    <meta name="twitter:title" content="Home | NotMongo">
    <meta name="twitter:image" content="https://notmongo.opensourceworks.org/preview.png">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Home | NotMongo">
    <meta property="og:image" content="https://notmongo.opensourceworks.org/preview.png">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Home
      - NotMongo
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/fira_code.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    
  <style>
    #page h2,
		#page h3 {
			text-align: left;
		}

		#page h2 {
			font-size: 1.7rem;
			border-bottom: 1px dashed #aaa;
			margin-top: 2em;
		}

		#page h3 {
			font-size: 1.5rem;
		}

		#page h4 {
			font-size: 1rem;
		}

		.title,
		.subtitle {
			margin-bottom: 0;
		}

		.subtitle,
		.tagline {
			margin-top: 0;
		}

		.title {
			font-size: 3rem;
		}

		.subtitle {
			font-size: 2rem;
		}

		.tagline {
			font-size: 1rem;
			font-style: italic;
			border-top: 1px solid #ccc;
			border-bottom: 1px solid #ccc;
			padding: 2px 5px;
			text-align: center;
		}

		.get-started {
			font-family: 'Bebas Neue', sans-serif;
			font-weight: normal;
			font-size: 2rem;
			text-align: center;
			margin: 1em;
		}

		.get-started a {
			color: black;
			font-weight: normal;
			background-color: #ccc;
			border: 1px solid #ccc;
			padding: 3px 10px;
			text-decoration: none;
		}

		.get-started a:hover {
			background-color: white;
		}

		img.downloadlogo {
			height: 30px;
			width: 130px;
			position: absolute;
			top: 10px;
			left: 15px;
			z-index: 999;
			background: red;
			opacity: 0 !important;
		}
  </style>

  </head>
  <body>
    <nav id="menu" class="centered">
      <a href="/">Home</a>
      •
      <a href="https://duckdb.org/">DuckDB</a>
      •
      <a href="https://community-extensions.duckdb.org/index.html">DuckDB Community Extensions</a>
      •
      <a href="https://github.com/jeroenflvr/rest-api-extension" target="_blank">
        Code
      </a>
    </nav>
    <div id="content">
      
  <h1 class="centered title">NotMongo</h1>
  <h2 class="centered subtitle">A Maybe DuckDB Extension for JSON APIs</h2>
  <p class="centered tagline">
    <img src="/DuckDB_Logo-horizontal.svg" alt="">DuckDB. Is there anything they can't do?!
  </p>
  <div id="page"><div class="block warning"><h1>Warning</h1><p>This DuckB Extension is a test.<br>To help me understand DuckDB and maybe use JSON APIs.</p><p>-- Using <a href="https://zine-ssg.io/" target="_blank">Zine</a>'s theme just because it's awesome and convenient. --</p></div><h2>What?</h2><p>I'm discovering how DuckDB works internally. I've been using it mainly for ad hoc stuff with the excellent cli. Also, I have a few use cases for accessing json data from api's.  Some are very simple, others are similar to MongoDB.</p><p>I could have used the already excellent <a href="https://duckdb.org/docs/extensions/json" target="_blank">json</a> extension with an external data fetcher, or even the <a href="https://community-extensions.duckdb.org/extensions/shellfs.html" target="_blank">shellfs</a> extension with curl.  Actually, that's how i do it today, use curl and pipe into the read_json /dev/stdin source. However, when I'm in the CLI, I want to stay there.  Especially when I'm running multiple consecutive queries for joins etc.</p><h2>Why this site?</h2><p>I want to document for future self.  Also, there's this excellent <em><a href="https://blog.debug.sexy/" target="_blank">at the boundary</a></em> blog. Started at about the same time I was looking into table functions and realizing there was no good documentation and examples (yet).</p><h2>Scalar functions</h2><p>These return a single value. The <a href="https://github.com/duckdb/extension-template" target="_blank">extension template</a> has the Quack example.</p><h2>Table functions</h2><p>Obviously, these return tables.  Retrieve data, process schema and data types. There are no good starters for this yet.  You can have a look at the parquet extension or the json extension, but they are a bit of a handful to get started with.</p><p>Supports threaded execution.</p><h2>Anatomy of the table function</h2><h3>Register the TableFunction</h3><ul><li>bind</li><li>init</li><li>table function<ul><li>filer pushdown (where)</li><li>projection pushdown (columns)</li><li>pushdown complex filter</li><li>positional and named parameters</li><li>extension options: PRAGMA/SET</li><li>cardinality</li></ul></li></ul><p><img src="/example_tf.png" alt=""></p><h3>Order of execution</h3><ol><li><p>bind</p><p>Here, we have access to positional and named arguments.<br>This is where I get the schema from the extension's configuration or from a separate endpoint. Return a struct with whatever we want to pass further down the line.</p></li><li><p>init</p><p>When projection_pushdown is enabled, we get the id of the columns from the SELECT statement. Return these.</p></li><li><p>execute table function</p><p>Get the schema, column ids, filters, etc. Order_by and limit are not part of any pushdown, however, they are accessible through the ResultModifier class.</p><p>This is where we get the data from a json api (paged and threaded), parse and return.</p></li></ol></div>

    </div>
  </body>
</html>