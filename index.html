<!DOCTYPE html>
<html>
  <head id="head">
    <meta charset="UTF-8">
    <meta name="description" content="NotMongo: A Maybe DuckDB Extension for JSON APIs">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@croloris">
    <meta name="twitter:author" content="@croloris">
    <meta name="twitter:description" content="NotMongo: A Maybe DuckDB Extension for JSON APIs">
    <meta name="twitter:title" content="Home | NotMongo">
    <meta name="twitter:image" content="https://notmongo.opensourceworks.org/preview.png">
    <meta property="og:type" content="website">
    <meta property="og:title" content="Home | NotMongo">
    <meta property="og:image" content="https://notmongo.opensourceworks.org/preview.png">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title id="title">
      Home
      - NotMongo
    </title>
    <link rel="stylesheet" type="text/css" href="/fonts.css">
    <link rel="stylesheet" type="text/css" href="/fira_code.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
    <link rel="stylesheet" type="text/css" href="/highlight.css">
    
  <style>
    #page h2,
		#page h3 {
			text-align: left;
		}

		#page h2 {
			font-size: 1.7rem;
			border-bottom: 1px dashed #aaa;
			margin-top: 2em;
		}

		#page h3 {
			font-size: 1.5rem;
		}

		#page h4 {
			font-size: 1rem;
		}

		.title,
		.subtitle {
			margin-bottom: 0;
		}

		.subtitle,
		.tagline {
			margin-top: 0;
		}

		.title {
			font-size: 3rem;
		}

		.subtitle {
			font-size: 2rem;
		}

		.tagline {
			font-size: 1rem;
			font-style: italic;
			border-top: 1px solid #ccc;
			border-bottom: 1px solid #ccc;
			padding: 2px 5px;
			text-align: center;
		}

		.get-started {
			font-family: 'Bebas Neue', sans-serif;
			font-weight: normal;
			font-size: 2rem;
			text-align: center;
			margin: 1em;
		}

		.get-started a {
			color: black;
			font-weight: normal;
			background-color: #ccc;
			border: 1px solid #ccc;
			padding: 3px 10px;
			text-decoration: none;
		}

		.get-started a:hover {
			background-color: white;
		}

		img.downloadlogo {
			height: 30px;
			width: 130px;
			position: absolute;
			top: 10px;
			left: 15px;
			z-index: 999;
			background: red;
			opacity: 0 !important;
		}
  </style>

  </head>
  <body>
    <nav id="menu" class="centered">
      <a href="/">Home</a>
      •
      <a href="https://duckdb.org/">DuckDB</a>
      •
      <a href="https://community-extensions.duckdb.org/index.html">DuckDB Community Extensions</a>
      •
      <a href="https://github.com/jeroenflvr/rest-api-extension" target="_blank">
        Code
      </a>
    </nav>
    <div id="content">
      
  <h1 class="centered title">NotMongo</h1>
  <h2 class="centered subtitle">A Maybe DuckDB Extension for JSON APIs</h2>
  <p class="centered tagline">
    <img src="/DuckDB_Logo-horizontal.svg" alt="">DuckDB. Is there anything they can't do?!
  </p>
  <div id="page"><div class="block warning"><h1>Warning</h1><p>This DuckB Extension is in early stage and not mature enough for public yet. This DuckB Extension is in early stage and not mature enough for public yet.</p><p>-- Using <a href="https://zine-ssg.io/" target="_blank">Zine</a>'s theme just because it's awesome and convenient. --</p></div><h2>What?</h2><p>I'm discovering how DuckDB works internally. I've been using it mainly for ad hoc stuff with the excellent cli. Also, I have a few use cases for accessing json data from api's.  Some are very simple, others are similar to MongoDB.</p><p>I could have used the already excellent <a href="https://duckdb.org/docs/extensions/json" target="_blank">json</a> extension with an external data fetcher, or even the <a href="https://community-extensions.duckdb.org/extensions/shellfs.html" target="_blank">shellfs</a> extension with curl.  Actually, that's how i do it today, use curl and pipe into the read_json /dev/stdin source. However, when I'm in the cli, I want to stay there.  Especially when I'm running multiple consecutive queries for joins etc.</p><h2>Why this site?</h2><p>Documenting for future self.  Also, there's this excellent <em><a href="https://blog.debug.sexy/" target="_blank">at the boundary</a></em> blog. Started at about the same time I was looking into table functions. There was no good documentation and examples at the time of this writing.</p><h2>Where to start</h2><ul><li><a href="https://duckdb.org/docs/dev/building/building_extensions.html" target="_blank">duckdb: build extensions</a></li><li><a href="https://blog.debug.sexy/" target="_blank">at the boundary</a>: explains how to get started with table functions with examples.</li><li>read the duckdb extensions code: <a href="https://github.com/duckdb/duckdb/blob/main/extension/json/json_extension.cpp" target="_blank">json</a>, <a href="https://github.com/duckdb/duckdb/blob/main/extension/parquet/parquet_extension.cpp" target="_blank">parquet</a></li><li><a href="https://github.com/duckdb/duckdb/tree/main/src/function/table" target="_blank">table function source</a> Documenting for future self.  Also, there's this excellent <em><a href="https://blog.debug.sexy/" target="_blank">at the boundary</a></em> blog. Started at about the same time I was looking into table functions. There was no good documentation and examples at the time of this writing.</li></ul><h2>Where to start</h2><ul><li><a href="https://duckdb.org/docs/dev/building/building_extensions.html" target="_blank">duckdb: build extensions</a></li><li><a href="https://blog.debug.sexy/" target="_blank">at the boundary</a>: explains how to get started with table functions with examples.</li><li>read the duckdb extensions code: <a href="https://github.com/duckdb/duckdb/blob/main/extension/json/json_extension.cpp" target="_blank">json</a>, <a href="https://github.com/duckdb/duckdb/blob/main/extension/parquet/parquet_extension.cpp" target="_blank">parquet</a></li><li><a href="https://github.com/duckdb/duckdb/tree/main/src/function/table" target="_blank">table function source</a></li></ul><h2>Scalar functions</h2><p>These return a single value. The <a href="https://github.com/duckdb/extension-template" target="_blank">extension template</a> has the Quack example.</p><h2>Table functions</h2><p>Obviously, these return tables.  Retrieve data, process schema and data types. There are no good starters for this yet.  You can have a look at the parquet extension or the json extension, but they are a bit of a handful to get started with.</p><p>Supports threaded execution.</p><h2>Anatomy of the table function</h2><h3>Register the TableFunction</h3><ul><li>bind</li><li>init</li><li>table function<ul><li>filer pushdown (where)</li><li>projection pushdown (columns)</li><li>pushdown complex filter</li><li>positional and named parameters</li><li>extension options: PRAGMA/SET</li><li>cardinality</li></ul></li></ul><pre><code class="c">    <span class="keyword">static</span> <span class="type">void</span> <span class="function">LoadInternal</span>(<span class="type">DatabaseInstance</span> <span class="operator">&</span><span class="variable">instance</span>) {
            auto <span class="type">myTableFunc</span><span class="variable"></span><span class="constant"></span> <span class="operator">=</span> <span class="function">TableFunction</span>(<span class="string">&quot;query_json_api&quot;</span>, {}, <span class="variable">myTableFunction</span>, <span class="variable">myBindFunction</span>, <span class="variable">myInitFunction</span>)<span class="delimiter">;</span>
        <span class="variable">myTableFunc</span><span class="delimiter">.</span><span class="property">filter_pushdown</span> <span class="operator">=</span> false<span class="delimiter">;</span>
        <span class="variable">myTableFunc</span><span class="delimiter">.</span><span class="property">projection_pushdown</span> <span class="operator">=</span> true<span class="delimiter">;</span>    
        <span class="variable">myTableFunc</span><span class="delimiter">.</span><span class="property">cardinality</span> <span class="operator">=</span> <span class="variable">myCardinalityFunction</span><span class="delimiter">;</span>
        <span class="variable">myTableFunc</span><span class="delimiter">.</span><span class="property">pushdown_complex_filter</span> <span class="operator">=</span> <span class="variable">pushdownComplexFilter</span><span class="delimiter">;</span>

        <span class="variable">myTableFunc</span><span class="delimiter">.</span><span class="property">named_parameters</span>[<span class="string">&quot;options&quot;</span>] <span class="operator">=</span> <span class="variable">LogicalType</span>::<span class="variable">VARCHAR</span><span class="delimiter">;</span>
        <span class="variable">myTableFunc</span><span class="delimiter">.</span><span class="property">named_parameters</span>[<span class="string">&quot;api&quot;</span>] <span class="operator">=</span> <span class="variable">LogicalType</span>::<span class="variable">VARCHAR</span><span class="delimiter">;</span>

        <span class="label">ExtensionUtil</span>::<span class="function">RegisterFunction</span>(<span class="variable">instance</span>, <span class="variable">myTableFunc</span>)<span class="delimiter">;</span>
        
        auto <span class="operator">&</span><span class="variable">config</span> <span class="operator">=</span> <span class="variable">DBConfig</span>::<span class="function">GetConfig</span>(<span class="variable">instance</span>)<span class="delimiter">;</span>

        <span class="variable">config</span><span class="delimiter">.</span><span class="function">AddExtensionOption</span>(<span class="string">&quot;rest_api_config_file&quot;</span>, <span class="string">&quot;REST API Config File Location&quot;</span>, <span class="variable">LogicalType</span>::<span class="variable">VARCHAR</span>,
                                <span class="function">Value</span>(<span class="string">&quot;rest_api_extension.json&quot;</span>))<span class="delimiter">;</span>

    }
</code></pre>
<h3>Order of execution</h3><ol><li><p>bind</p><p>Here, we have access to positional and named arguments.<br>This is where I get the schema from the extension's configuration or from a separate endpoint. Return a struct with whatever we want to pass further down the line.</p></li><li><p>init</p><p>When projection_pushdown is enabled, we get the id of the columns from the SELECT statement. Return these.</p></li><li><p>execute table function</p><p>Get the schema, column ids, filters, etc. Order_by and limit are not part of any pushdown, however, they are accessible through the ResultModifier class.</p><p>This is where we get the data from a json api (paged and threaded), parse and return.</p></li></ol><h3>doubts</h3><p>The json extension is really really good and I don't want to duplicate code or reinvent the wheel.  I haven't found a supported and documented way to reuse the extension or parts of it.  I'm exploring the Catalog (duckdb/catalog/catalog.hpp) and it's entries, but I'm not too keen on using undocumented internal APIs. Also, this means there will be a dependency that has to be clear and well documented.  We'll see.</p><hr><div align="right" style="color: orange; font-size: 0.6rem;"> jeroenflvr</div>
</div>

    </div>
  </body>
</html>